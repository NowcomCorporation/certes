{
  "name": "Certes",
  "tagline": "A client implantation for the Automated Certificate Management Environment (ACME) protocol",
  "body": "# Certes ACME Client\r\n\r\n[![Travis](https://travis-ci.org/fszlin/certes.svg?branch=master)](https://travis-ci.org/fszlin/certes)\r\n[![AppVeyor](https://ci.appveyor.com/api/projects/status/4wwiivqs8rl0l63q/branch/master?svg=true)](https://ci.appveyor.com/project/fszlin/certes/branch/master)\r\n[![NuGet](https://buildstats.info/nuget/certes)](https://www.nuget.org/packages/certes/)\r\n[![MyGet](https://buildstats.info/myget/dymetis/certes?includePreReleases=true)](https://www.myget.org/feed/dymetis/package/nuget/certes)\r\n\r\nCertes is a client implantation for the Automated Certificate Management\r\nEnvironment (ACME) protocol, build on .NET Core. It is aimed to provide a easy\r\nto use API for managing certificates using scripts during build process.\r\n\r\nBefore [Let's Encrypt](https://letsencrypt.org), SSL/TLS certificate for HTTPS\r\nwas a privilege for who can afford it. With Certes, you can quickly generate\r\ncertificates using .NET or command line, and it is **free**.\r\n\r\n# Get Certified in 5 Minutes\r\n\r\nInstall [.NET Core](https://www.microsoft.com/net/core)\r\n\r\nDownload the [latest release](https://github.com/fszlin/certes/releases), \r\n   and extract the files\r\n\r\nRun these commands to start the authorization process\r\n\r\n```Bash\r\n    # Create new registration on LE, and accept terms of services\r\n    certes register --email your_email@my_domain.com --agree-tos\r\n\r\n    # Initialize authorization for host name(s)\r\n    certes authz --v my_domain.com #--v www.my_domain.com --v my_domain2.com\r\n\r\n    # Show the http-01 key authorization for specified host name(s)\r\n    certes authz --key-authz http-01 --v my_domain.com #--v www.my_domain.com --v my_domain2.com\r\n```\r\n\r\nMake changes to your site so that it serves the **key authorization string** \r\n   on the well know path.\r\n  * The **key authorization string** consists of the token and the thumbprint\r\n    of the registration key, in form of `<token>.<thumbprint>`\r\n  * You can simply save the **key authorization string** in a text file, and\r\n    upload it to `http://my_domain.com/.well-known/acme-challenge/<token>`\r\n  * For testing purposes, if you are hosting an ASP.NET Core app, you can add\r\n    the following to ```Configure``` method of ```Startup``` class\r\n\r\n```C#\r\n        app.Map(\"/.well-known/acme-challenge\", sub =>\r\n        {\r\n            sub.Run(async context =>\r\n            {\r\n                var path = context.Request.Path.ToUriComponent();\r\n                if (path?.Length > 1 && path.StartsWith(\"/\"))\r\n                {\r\n                    context.Response.ContentType = \"plain/text\";\r\n                    await context.Response.WriteAsync($\"{path.Substring(1)}.<thumbprint>\");\r\n                }\r\n            });\r\n        });\r\n```\r\n\r\n  * For more details, see [section 6.4.1 of the ACME spec](https://tools.ietf.org/html/draft-ietf-acme-acme-02#section-6.4.1)\r\n\r\nContinue the authorization process and generate the certificate\r\n\r\n```Bash\r\n    # Complete the http-01 challenge\r\n    certes authz --complete-authz http-01 --v my_domain.com #--v www.my_domain.com --v my_domain2.com\r\n\r\n    # Check the challenge status, wait until it becomes \"valid\"\r\n    certes authz --refresh http-01 --v my_domain.com #--v www.my_domain.com --v my_domain2.com\r\n\r\n    # Create a certificate with the distinguished name, and additional SAN names\r\n    certes cert --name mycert --distinguished-name \"CN=CA, ST=Ontario, L=Toronto, O=Certes, OU=Dev, CN=my_domain.com\" #--v www.my_domain.com --v my_domain2.com\r\n\r\n    # Export the certificate in DER\r\n    certes cert --name mycert --export-cer ./mycert.cer\r\n\r\n    # Export the certificate's private key in PEM\r\n    certes cert --name mycert --export-key ./mycert.key\r\n\r\n    # Export the certificate with private key in PFX\r\n    certes cert --name mycert --export-pfx ./mycert.pfx --password abcd1234\r\n\r\n    # Revoke the certificate\r\n    certes cert --name mycert --revoke\r\n```\r\n\r\nInstall the certificate on your host server.\r\n\r\nMore...\r\n  * Append ```--server https://acme-staging.api.letsencrypt.org/directory``` to the commands\r\n    for testing again LE staging server.\r\n  * By default, the account and contextual data are saved in **data.json**, \r\n    use ```--path``` option to change the location.\r\n\r\n# Get Started\r\n\r\nYou can get Certes by grabbing the latest\r\n[NuGet package](https://www.nuget.org/packages/Certes).\r\n\r\n```C#\r\nusing (var client = new AcmeClient(WellKnownServers.LetsEncrypt))\r\n{\r\n    // Create new registration\r\n    var account = await client.NewRegistraton(\"mailto:test@example.com\");\r\n\r\n    // Accept terms of services\r\n    account.Data.Agreement = account.GetTermsOfServiceUri();\r\n    account = await client.UpdateRegistration(account);\r\n\r\n    // Initialize authorization\r\n    var authz = await client.NewAuthorization(new AuthorizationIdentifier\r\n    {\r\n        Type = AuthorizationIdentifierTypes.Dns,\r\n        Value = \"www.my_domain.com\"\r\n    });\r\n\r\n    // Comptue key authorization for http-01\r\n    var httpChallengeInfo = authz.Data.Challenges.Where(c => c.Type == ChallengeTypes.Http01).First();\r\n    var keyAuthString = client.ComputeKeyAuthorization(httpChallengeInfo);\r\n    \r\n    // Do something to fullfill the challenge,\r\n    // e.g. upload key auth string to well known path, or make changes to DNS\r\n\r\n    // Info ACME server to validate the identifier\r\n    var httpChallenge = await client.CompleteChallenge(httpChallengeInfo);\r\n\r\n    // Check authorization status\r\n    authz = await client.GetAuthorization(httpChallenge.Location);\r\n    while (authz.Data.Status == EntityStatus.Pending)\r\n    {\r\n        // Wait for ACME server to validate the identifier\r\n        await Task.Delay(10000);\r\n        authz = await client.GetAuthorization(httpChallenge.Location);\r\n    }\r\n\r\n    if (authz.Data.Status == EntityStatus.Valid)\r\n    {\r\n        // Create certificate\r\n        var csr = new CertificationRequestBuilder();\r\n        csr.AddName(\"CN\", \"www.my_domain.com\");\r\n        var cert = await client.NewCertificate(csr);\r\n\r\n        // Export Pfx\r\n        var pfxBuilder = cert.ToPfx();\r\n        var pfx = pfxBuilder.Build(\"my-free-cert\", \"abcd1234\");\r\n        File.WriteAllBytes(\"./my-free-cert.pfx\", pfx);\r\n\r\n        // Revoke certificate\r\n        await client.RevokeCertificate(cert);\r\n    }\r\n}\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}